# Planning Your Code

<!-- DO NOT FORGET TO SAY SOMETHIN ABOUT LICENSES !! -->

If you associate programming more often than not with hours of fiddling, tweaking
and fighting to galvanize approaches found on online this chapter is for you. 

*Planning Your Code* shares a blueprint to organise your code and to accompany the evolution of your project:
start out with explorative experiments, define your interface, narrow down to a proof of
concept and scale up. Hopefully the tips, tricks and the guidance in this chapter will help you to
experience the rewarding feeling of a software project coming together like a plan originated by Hannibal Smith. 


- maybe overview sketch here... decision tree. 

## Folder Structure

<!-- packaging not for guru's illustration
Yoda: Over the days are when creating a package for gurus was only. 
--> 

Obviously every project is different and not every aspect (folder) is needed for every project, 
but there are definitely well established blueprints, guides and conventions that help almost any project. 
First, unlike projects based on an Office document which focuses on one single file, 
understand a research project will live in a folder with many subfolder and files, not in a single file. 
Second, as with most conventions and guidelines there are more approaches and gurus than 
heavyweight champions. 

Here is an approach that I find practical for applied, empirical research projects involving code. It's the basic structure of an R package, but it's proven helpful beyond creating packages. Some of its core idea transfer also well to other languages. That being said, don't take it religiously, take away what works for you. 

In R and Python (and many other languages), package or library sources are nothing else but code organized in a folder that follows certain conventions. For R, simply create a folder named like the your package / project and create the following folders (when needed) inside of it.

Before we start, let me drop a quick note on naming conventions. Naming for folders, functions and file names. 

- Do NOT use spaces in folder or file names! Never. If you need lengthy descriptions, use underscores '_', dashes '-' or camelCase. 

- avoid umlauts and special characters. Encoding and internationalization is worth a book of its own. It's not like modern programming environments can't handle it, but it will introduce further complications you do not want to run into without a deep understanding of encoding. This is especially true for cross
platform collaboroations (Windows vs. Unix OS).

- either go for camelCase, snake_case or kebap-case. Otherwise prefer lower case
characters. Also make sure to not switch styles within a project. There a plenty of style guides around, go with whatever your lab or community goes. 


- R
- data
- docs
- vignettes
- src 
- inst
- man



**R**

A folder to store function definitions as opposed to function calls. Typically 
every function goes into a separate files. Sometimes it makes sense to group multiple functions into a single file when the they are closely related. Another reason for putting more than one functions into a single file is when you have a collection of relatively simple, short helper functions. This folder MUST NOT contain calls.

```{r}
my_func_def <- function(param1, param2){
  # here goes the function body, i.e., what the function does
  a <- (param1 + param2) * param3
  # Note that in R, return statements are not necessary and even
  # relatively uncommon, R will return the last unassigned statement
  return(a)
}
```

**man** 

This folder contains the context manual of your package. This is basically a function (and dataset) specific documentation. It's what you see when you run `?function_name`. The content of the man folder is usually created automatically from the roxygen style documentation (note the #' styled comments) during a ```devtools::document()`` run. Back in the days when people wore pijamas and
lived life slow, the the man folder was filled up manually with some LaTeX reminiscant .rd files, but ever since R Studio took over in 2012, most developer used Roxygen and render the function reference part of the documentation from 
markdown. 


```{r, eval=FALSE}
#' Sum of Parameters Multiplied by First Input
#'
#' This functions only exists as a show case. 
#' It's useless but nevertheless exported to the NAMESPACE of this
#' package so users can see it and call the function by it's name.
#'
#' @param param1 numeric input 
#' @param param2 numeric input 
#' @export
my_func_def <- function(param1, param2){
  # here goes the function body, i.e., what the function does
  a <- (param1 + param2) * param1
  # Note that in R, return statements are not necessary and even
  # relatively uncommon, R will return the last unassigned statement
  return(a)
}
```





**docs**

This folder is typically not filled with content manually. When pushed to github
a docs folder can easily be published as website using [Github Pages](https://pages.github.com/). With Github pages you can host a decently styled modern website for free. Software projects often use GitHub Pages to market a product or project or simply for documentation purposes. All you need to do is check a couple of options inside the Github Web GUI and make sure the docs folder contains .md or .html files as well as stylesheets (.css). The latter make sound a bit like Latin to people without a basic development background, but there is plenty of help. The R ecosystem offers different flavors of the same idea: use a bit of markdown + R to generate website code. There is blogdown for your personal website or blog. There is pkgdown for your packages documentation. And there is even bookdown to write an online book like this. Write the markdown file, render it as HTML into the docs folder, push the docs folder to GitHub. Done. Your website will be online at username.github.io/reponame.

Here's a an example of a package down website: https://mbannert.github.io/timeseriesdb/

**data**

If you have file based data like .csv, .RData, .json or even .xlsx put them in here. Keeping data in a separate folder inside the project directory helps to keep reference to the data relative. There is nothing more greenhorn like then 
```r read.csv("C:\mbannert\My Documents\some_data.csv") ```. Even if you like this book, I doubt you have a folder named 'mbannert' on your computer. Ah, an in case you wondered, extensive use of ```setwd()``` is even worse. Keep you reference to data (and functions alike) relative. If you are sourcing data from a remote NAS drive as it is common at many university you can simply mount this drive to you folder (LTMGTFY: Windows / OSX).

**vignettes**

Admittedly not the most intuitive names for a folder that is supposed to contain articles. Vignettes are part of the documentation of a good package. It's kind of a description as if you were to write a paper about your package, including some examples of how to use it. For modern packages, vignettes are often part of their package down based online documentation. Feel free, to name this folder differently, though sticking to the convention will make it easier to turn your 
project into a project at a later stage. This folder typically contains Markdown or RMarkdown files. 


**src**

The source folder is just here for the sake of completeness and is not needed in projects that only involve R source code. It's reserved for those parts of a package that need compilation, e.g., C++ or FORTRAN source code. 


**inst**

When you install an R package using `install.packages()` it will be installed in some deep dungeon on your computer where R lives within your OS. The inst folder allows you to ship non R files with your installation. The files of the inst folder will just be copied into the package root folder inside your installation of that package. 

*inst* is also a great place to store experimental function calls or playground files once the package ambitions become more concrete and those type of files do not live conveniently in the project roo anymore. Also I sometimes put shiny apps for local use into the inst folder if I want to make them part of a package. 





## Documentation

First things first. Write the first bit of documentation before your first line of 
code. Documentation written with hindsight solely will always be written with the
mindset of someone who thinks the approach is easy because the issue was just solved. 
Also, the motivation the think about the problem is much lower once it's fixed. 
Hence I encourage you, to write up a bit of pseudo code to start get started. 

- may look like this. 


## Explore! Write Scripts.

Get your hands dirty. Run experiments. How should the new graph look like? 
Try out things interactively. Can we read in the data correctly? Are the axes labels
large in enough? Is the color scheme suitable? 

The most important feature for their popularity in social sciences is the 
interactivity of R and Python. Both languages are interpreted, allowing to send 
commands to the interpreter line-by-line and to get a result back immediately. 
This is tremendously helpful when trying things out, but also when reading code 
written by more experienced developers. The ability to send code to the console
line by line can be very handy when trying to follow more complex statements. 

- read inside out

- 

## Design Your Interface

Once you know a bit more about your direction of travel, it's time to think about
how users interact with your program: Will your code just act as a storage pit of tools, 
a loose collection of commands for adhoc use? Are others using the program, too?
?  Will there be machine-to-machine interaction?


- pseudo code is


## 


